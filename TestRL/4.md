Что не так в этом коде?  
Перечислите, какие недостатки вы видите. Предложите свой вариант рефакторинга.

```cpp
#include <stdio.h>
 
class Feature
{
public:
    enum FeatureType {eUnknown, eCircle, eTriangle, eSquare};
 
    Feature() : type(eUnknown), points(0) {    }
 
    ~Feature()
    {
        if (points)
            delete points;
    }
 
    bool isValid() 
    {
        return type != eUnknown;
    }
 
    bool read(FILE* file)
    {        
        if (fread(&type, sizeof(FeatureType), 1, file) != sizeof(FeatureType))
            return false;
        short n = 0;
        switch (type) 
        {
        case eCircle: n = 3; break;
        case eTriangle:    n = 6; break;
        case eSquare: n = 8; break;
        default: type = eUnknown; return false;
        }
        points = new double[n];
        if (!points)
            return false;
        return fread(&points, sizeof(double), n, file) == n*sizeof(double);
    }
    void draw()
    {
        switch (type)
        {
        case eCircle: drawCircle(points[0], points[1], points[2]); break;
        case eTriangle:    drawPoligon(points, 6); break;
        case eSquare: drawPoligon(points, 8); break;
        }
    }
 
protected:
    void drawCircle(double centerX, double centerY, double radius);
    void drawPoligon(double* points, int size);
 
    double* points;
    FeatureType type;        
};
 
int main(int argc, char* argv[])
{
    Feature feature;
    FILE* file = fopen("features.dat", "r");
    feature.read(file);
    if (!feature.isValid())
        return 1;
    return 0;
}

```
В этом коде есть проблемы:

### 1. Проблемы с управлением памятью
- Не проверяется `file` на NULL после открытия
- Нет обработки ошибок при выделении памяти (хотя `new` в C++ бросает исключение, а не возвращает NULL)
- Утечка памяти: если `fread` для точек завершится с ошибкой, память не освобождается
- Нет конструктора копирования и оператора присваивания (нарушение "правила трёх")

### 2. Проблемы безопасности
- Чтение данных из файла без проверки их корректности
- Использование сырых указателей вместо умных или контейнеров

### 3. Прочие проблемы
- Метод `isValid()` не помечен как `const`
- В методе `read()` неправильная проверка результата `fread` (сравнение с sizeof вместо количества элементов)
- Опечатка в названии метода `drawPoligon` (должно быть `drawPolygon`)
- Нет обработки случая, когда type == eUnknown в методе draw()
- Не закрывается файл в main()

### Рефакторинг:

```cpp
#include <stdio.h>
#include <vector>
#include <memory>

class Feature {
public:
    enum FeatureType { eUnknown, eCircle, eTriangle, eSquare };

    Feature() : type(eUnknown) {}
    
    bool isValid() const {
        return type != eUnknown;
    }

    bool read(FILE* file) {
        if (!file) return false;
        
        if (fread(&type, sizeof(FeatureType), 1, file) != 1) {
            type = eUnknown;
            return false;
        }
        
        size_t n = 0;
        switch (type) {
            case eCircle:    n = 3; break;
            case eTriangle:  n = 6; break;
            case eSquare:    n = 8; break;
            default:
                type = eUnknown;
                return false;
        }
        
        points.resize(n);
        if (fread(points.data(), sizeof(double), n, file) != n) {
            points.clear();
            type = eUnknown;
            return false;
        }
        
        return true;
    }

    void draw() const {
        switch (type) {
            case eCircle:
                drawCircle(points[0], points[1], points[2]);
                break;
            case eTriangle:
                drawPolygon(points.data(), 6);
                break;
            case eSquare:
                drawPolygon(points.data(), 8);
                break;
            case eUnknown:
                break;
        }
    }

protected:
    void drawCircle(double centerX, double centerY, double radius) const;
    void drawPolygon(const double* points, int size) const;

private:
    std::vector<double> points;
    FeatureType type;        
};

int main(int argc, char* argv[]) {
    Feature feature;
    
    FILE* file = fopen("features.dat", "rb");
    if (!file) return 1;

    bool success = feature.read(file);
    fclose(file);
    
    if (!success || !feature.isValid())
        return 1;

    feature.draw();
    
    return 0;
}
```

Что изменено:
1. Замена сырого указателя на std::vector для автоматического управления памятью
2. Добавлена обработка ошибок при чтении файла
3. Исправлена проверка результатов fread()
4. Методы рисования сделаны константными
5. Добавлено закрытие файла в main()
6. Исправлена опечатка в имени метода drawPolygon()
7. Добавлена обработка случая eUnknown в методе draw()
8. Убраны ручные операции с памятью