Есть класс CodeGenerator, который умеет генерить код на разных языках.
Предложите рефакторинг с учетом, что количество языков будет расширяться

```cpp
class CodeGenerator
{
public:
    enum Lang {JAVA, C_PLUS_PLUS, PHP};
    CodeGenerator(Lang language) { _language=language; }
    std::string generateCode()
    {
        switch(_language) {
        case JAVA:        //return generated java code
        case C_PLUS_PLUS: //return generated C++ code
        case PHP:         //return generated PHP code
        }
        throw new std::logic_error("Bad language");
    }
    std::string someCodeRelatedThing() // used in generateCode()
    {
        switch(_language) {
        case JAVA:        //return generated java-related stuff
        case C_PLUS_PLUS: //return generated C++-related stuff
        case PHP:         //return generated PHP-related stuff
        }
        throw new std::logic_error("Bad language");
    }

private:
    Lang _language;
}

```

Для рефакторинга класса `CodeGenerator` с учетом возможного расширения количества языков, я предлагаю использовать паттерн "Стратегия" (Strategy), который позволит легко добавлять новые языки без модификации существующего кода:

```cpp
#include <iostream>
#include <memory>
#include <string>

// Абстрактный базовый класс для генерации кода
class ICodeGeneratorStrategy {
public:
    virtual ~ICodeGeneratorStrategy() = default;
    virtual std::string generateCode() = 0;
    virtual std::string someCodeRelatedThing() = 0;
};

// Конкретные реализации для каждого языка
class JavaCodeGenerator : public ICodeGeneratorStrategy {
public:
    std::string generateCode() override { /* return generated java code */ }
    std::string someCodeRelatedThing() override { /* return java-related stuff */ }
};

class CppCodeGenerator : public ICodeGeneratorStrategy {
public:
    std::string generateCode() override { /* return generated C++ code */ }
    std::string someCodeRelatedThing() override { /* return C++-related stuff */ }
};

class PhpCodeGenerator : public ICodeGeneratorStrategy {
public:
    std::string generateCode() override { /* return generated PHP code */ }
    std::string someCodeRelatedThing() override { /* return PHP-related stuff */ }
};

// Переработанный основной класс
class CodeGenerator {
public:
    enum Lang { JAVA, C_PLUS_PLUS, PHP };
    
    CodeGenerator(Lang language) {
        switch(language) {
            case JAVA:       _strategy = std::make_unique<JavaCodeGenerator>(); break;
            case C_PLUS_PLUS:_strategy = std::make_unique<CppCodeGenerator>(); break;
            case PHP:        _strategy = std::make_unique<PhpCodeGenerator>(); break;
            default: throw std::logic_error("Unsupported language");
        }
    }
    
    void setLanguage(Lang language) {
        *this = CodeGenerator(language);
    }
    
    std::string generateCode() {
        return _strategy->generateCode();
    }
    
    std::string someCodeRelatedThing() {
        return _strategy->someCodeRelatedThing();
    }

private:
    std::unique_ptr<ICodeGeneratorStrategy> _strategy;
};

int main() {
     try {
         // Создаем генератор для Java
         CodeGenerator javaGen(CodeGenerator::JAVA);
         std::cout << "=== Java Code ===" << "\n";
         std::cout << javaGen.generateCode() << "\n\n";
         std::cout << "Java tools: " << javaGen.someCodeRelatedThing() << "\n\n";

         // Создаем генератор для C++
         CodeGenerator cppGen(CodeGenerator::C_PLUS_PLUS);
         std::cout << "=== C++ Code ===" << "\n";
         std::cout << cppGen.generateCode() << "\n\n";
         std::cout << "C++ tools: " << cppGen.someCodeRelatedThing() << "\n\n";

         // Создаем генератор для PHP
         CodeGenerator phpGen(CodeGenerator::PHP);
         std::cout << "=== PHP Code ===" << "\n";
         std::cout << phpGen.generateCode() << "\n\n";
         std::cout << "PHP tools: " << phpGen.someCodeRelatedThing() << "\n\n";

         // Демонстрация смены стратегии на лету
         CodeGenerator dynamicGen(CodeGenerator::JAVA);
         std::cout << "=== Dynamic Language Change ===" << "\n";
         std::cout << dynamicGen.generateCode() << "\n";

         dynamicGen.setLanguage(CodeGenerator::PHP);
         std::cout << dynamicGen.generateCode() << "\n";

     } catch (const std::exception& e) {
         std::cerr << "Error: " << e.what() << "\n";
     }

     return 0;
}
```

Преимущества такого подхода:

1. **Открытость/закрытость**: Чтобы добавить новый язык, нужно просто создать новый класс-стратегию, не изменяя существующий код `CodeGenerator`.

2. **Упрощение тестирования**: Каждый генератор можно тестировать изолированно.

3. **Устранение switch-case**: Логика для каждого языка инкапсулирована в отдельном классе.

4. **Гибкость**: Можно легко менять стратегию во время выполнения.

5. **Чистота кода**: Каждый класс отвечает только за один язык, соблюдается принцип единственной ответственности.

Если нужно будет добавить новый язык (например, Python), достаточно будет:
1. Создать класс `PythonCodeGenerator`, унаследованный от `ICodeGeneratorStrategy`
2. Добавить новое значение в enum Lang
3. Добавить case в конструктор `CodeGenerator`

Это гораздо более масштабируемое решение, чем оригинальный вариант с множественными switch-case блоками.